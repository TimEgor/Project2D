; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	C:\Users\tim23\Documents\Visual Studio 2019\Projects\Project2D\Project2D\MemoryManager\Allocators\ChunkAllocator.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__3F31CF21_ChunkAllocator@h DB 01H
__B2D2BA86_ctype@h DB 01H
__79C7FC57_basetsd@h DB 01H
__1FEB9909_corecrt_memcpy_s@h DB 01H
__A751F051_corecrt_memory@h DB 01H
__9200769A_corecrt_wstring@h DB 01H
__32E5F013_string@h DB 01H
__D545DD43_guiddef@h DB 01H
__D5DDFBF3_winnt@h DB 01H
__439612F0_processthreadsapi@h DB 01H
__5733279A_memoryapi@h DB 01H
__D4435474_winerror@h DB 01H
__B3ED30D4_winbase@h DB 01H
__DB057BA3_winuser@h DB 01H
__A7113148_winioctl@h DB 01H
__B49664B7_stdlib@h DB 01H
__EC5BC72C_propidl@h DB 01H
__6DA674A0_oleauto@h DB 01H
__A118E6DC_stralign@h DB 01H
__1E01F8EA_Heap@h DB 01H
__8B404B8B_vcruntime_new@h DB 01H
__4C8DB69C_cstddef DB 01H
__741AE07E_corecrt_math@h DB 01H
__E9466C31_cstdlib DB 01H
__77E6CA79_type_traits DB 01H
__20BB4341_malloc@h DB 01H
__604808BE_vcruntime_exception@h DB 01H
__8655F6A9_exception DB 01H
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__C6E16F6F_corecrt_wconio@h DB 01H
__6D390390_corecrt_wio@h DB 01H
__1157D6BA_corecrt_wtime@h DB 01H
__1DC1E279_stat@h DB 01H
__93DC0B45_wchar@h DB 01H
__EC89C42C_vcruntime_typeinfo@h DB 01H
__AE3815F6_typeinfo DB 01H
__A47FD3F7_limits DB 01H
__DEE7E6EF_xutility DB 01H
__B4DE8A79_xmemory DB 01H
__18D1DF79_memory DB 01H
__415253A4_cmath DB 01H
__F42B12D8_ChunkAllocator@cpp DB 01H
msvcjmc	ENDS
PUBLIC	??0ChunkAllocator@@QAE@XZ			; ChunkAllocator::ChunkAllocator
PUBLIC	??0ChunkAllocator@@QAE@$$QAV0@@Z		; ChunkAllocator::ChunkAllocator
PUBLIC	??1ChunkAllocator@@UAE@XZ			; ChunkAllocator::~ChunkAllocator
PUBLIC	??4ChunkAllocator@@QAEAAV0@$$QAV0@@Z		; ChunkAllocator::operator=
PUBLIC	?init@ChunkAllocator@@UAE_NPAVHeap@@II@Z	; ChunkAllocator::init
PUBLIC	?release@ChunkAllocator@@UAEXXZ			; ChunkAllocator::release
PUBLIC	?allocate@ChunkAllocator@@UAEPAXI@Z		; ChunkAllocator::allocate
PUBLIC	?deallocate@ChunkAllocator@@UAEXPAX@Z		; ChunkAllocator::deallocate
PUBLIC	?clean@ChunkAllocator@@UAEXXZ			; ChunkAllocator::clean
PUBLIC	?getHeap@ChunkAllocator@@UAEPAVHeap@@XZ		; ChunkAllocator::getHeap
PUBLIC	?size@ChunkAllocator@@UBEIXZ			; ChunkAllocator::size
PUBLIC	?getUsingSectorsNum@ChunkAllocator@@UBEIXZ	; ChunkAllocator::getUsingSectorsNum
PUBLIC	?getChunkSize@ChunkAllocator@@UBEIXZ		; ChunkAllocator::getChunkSize
PUBLIC	?getChunkNum@ChunkAllocator@@UBEIXZ		; ChunkAllocator::getChunkNum
PUBLIC	?isFull@ChunkAllocator@@UBE_NXZ			; ChunkAllocator::isFull
PUBLIC	?isInit@ChunkAllocator@@UBE_NXZ			; ChunkAllocator::isInit
PUBLIC	??_GChunkAllocator@@UAEPAXI@Z			; ChunkAllocator::`scalar deleting destructor'
PUBLIC	_ceilf
PUBLIC	__JustMyCode_Default
PUBLIC	??_7ChunkAllocator@@6B@				; ChunkAllocator::`vftable'
PUBLIC	??_R4ChunkAllocator@@6B@			; ChunkAllocator::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVChunkAllocator@@@8			; ChunkAllocator `RTTI Type Descriptor'
PUBLIC	??_R3ChunkAllocator@@8				; ChunkAllocator::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ChunkAllocator@@8				; ChunkAllocator::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ChunkAllocator@@8			; ChunkAllocator::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_EChunkAllocator@@UAEPAXI@Z:PROC		; ChunkAllocator::`vector deleting destructor'
EXTRN	?allocate@Heap@@QAEPAXI@Z:PROC			; Heap::allocate
EXTRN	?deallocate@Heap@@QAEXPAX@Z:PROC		; Heap::deallocate
EXTRN	__imp__ceil:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftol2:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@ChunkAllocator@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ChunkAllocator@@8 DD FLAT:??_R0?AVChunkAllocator@@@8 ; ChunkAllocator::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ChunkAllocator@@8
rdata$r	ENDS
;	COMDAT ??_R2ChunkAllocator@@8
rdata$r	SEGMENT
??_R2ChunkAllocator@@8 DD FLAT:??_R1A@?0A@EA@ChunkAllocator@@8 ; ChunkAllocator::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ChunkAllocator@@8
rdata$r	SEGMENT
??_R3ChunkAllocator@@8 DD 00H				; ChunkAllocator::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ChunkAllocator@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVChunkAllocator@@@8
data$rs	SEGMENT
??_R0?AVChunkAllocator@@@8 DD FLAT:??_7type_info@@6B@	; ChunkAllocator `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVChunkAllocator@@', 00H
data$rs	ENDS
;	COMDAT ??_R4ChunkAllocator@@6B@
rdata$r	SEGMENT
??_R4ChunkAllocator@@6B@ DD 00H				; ChunkAllocator::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVChunkAllocator@@@8
	DD	FLAT:??_R3ChunkAllocator@@8
rdata$r	ENDS
;	COMDAT ??_7ChunkAllocator@@6B@
CONST	SEGMENT
??_7ChunkAllocator@@6B@ DD FLAT:??_R4ChunkAllocator@@6B@ ; ChunkAllocator::`vftable'
	DD	FLAT:??_EChunkAllocator@@UAEPAXI@Z
	DD	FLAT:?init@ChunkAllocator@@UAE_NPAVHeap@@II@Z
	DD	FLAT:?release@ChunkAllocator@@UAEXXZ
	DD	FLAT:?allocate@ChunkAllocator@@UAEPAXI@Z
	DD	FLAT:?deallocate@ChunkAllocator@@UAEXPAX@Z
	DD	FLAT:?clean@ChunkAllocator@@UAEXXZ
	DD	FLAT:?getHeap@ChunkAllocator@@UAEPAVHeap@@XZ
	DD	FLAT:?size@ChunkAllocator@@UBEIXZ
	DD	FLAT:?getUsingSectorsNum@ChunkAllocator@@UBEIXZ
	DD	FLAT:?getChunkSize@ChunkAllocator@@UBEIXZ
	DD	FLAT:?getChunkNum@ChunkAllocator@@UBEIXZ
	DD	FLAT:?isFull@ChunkAllocator@@UBE_NXZ
	DD	FLAT:?isInit@ChunkAllocator@@UBE_NXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1ChunkAllocator@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_math.h
;	COMDAT _ceilf
_TEXT	SEGMENT
tv74 = -196						; size = 4
__X$ = 8						; size = 4
_ceilf	PROC						; COMDAT

; 641  :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __741AE07E_corecrt_math@h
	call	@__CheckForDebuggerJustMyCode@4

; 642  :             return (float)ceil(_X);

	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	mov	esi, esp
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__ceil
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	fstp	DWORD PTR tv74[ebp]
	fld	DWORD PTR tv74[ebp]

; 643  :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_ceilf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GChunkAllocator@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GChunkAllocator@@UAEPAXI@Z PROC			; ChunkAllocator::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ChunkAllocator@@UAE@XZ		; ChunkAllocator::~ChunkAllocator
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	32					; 00000020H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GChunkAllocator@@UAEPAXI@Z ENDP			; ChunkAllocator::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\tim23\Documents\Visual Studio 2019\Projects\Project2D\Project2D\MemoryManager\Allocators\ChunkAllocator.h
;	COMDAT ?isInit@ChunkAllocator@@UBE_NXZ
_TEXT	SEGMENT
tv66 = -205						; size = 1
_this$ = -8						; size = 4
?isInit@ChunkAllocator@@UBE_NXZ PROC			; ChunkAllocator::isInit, COMDAT
; _this$ = ecx

; 54   : 	virtual bool isInit() const { return chunks; }

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __3F31CF21_ChunkAllocator@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN3@isInit
	mov	BYTE PTR tv66[ebp], 1
	jmp	SHORT $LN4@isInit
$LN3@isInit:
	mov	BYTE PTR tv66[ebp], 0
$LN4@isInit:
	mov	al, BYTE PTR tv66[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?isInit@ChunkAllocator@@UBE_NXZ ENDP			; ChunkAllocator::isInit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\tim23\Documents\Visual Studio 2019\Projects\Project2D\Project2D\MemoryManager\Allocators\ChunkAllocator.h
;	COMDAT ?isFull@ChunkAllocator@@UBE_NXZ
_TEXT	SEGMENT
tv67 = -208						; size = 4
_this$ = -8						; size = 4
?isFull@ChunkAllocator@@UBE_NXZ PROC			; ChunkAllocator::isFull, COMDAT
; _this$ = ecx

; 53   : 	virtual bool isFull() const { return usingChunksNum == chunksNum; }

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __3F31CF21_ChunkAllocator@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+28]
	jne	SHORT $LN3@isFull
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@isFull
$LN3@isFull:
	mov	DWORD PTR tv67[ebp], 0
$LN4@isFull:
	mov	al, BYTE PTR tv67[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?isFull@ChunkAllocator@@UBE_NXZ ENDP			; ChunkAllocator::isFull
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\tim23\Documents\Visual Studio 2019\Projects\Project2D\Project2D\MemoryManager\Allocators\ChunkAllocator.h
;	COMDAT ?getChunkNum@ChunkAllocator@@UBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getChunkNum@ChunkAllocator@@UBEIXZ PROC		; ChunkAllocator::getChunkNum, COMDAT
; _this$ = ecx

; 51   : 	virtual size_t getChunkNum() const { return chunksNum; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __3F31CF21_ChunkAllocator@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?getChunkNum@ChunkAllocator@@UBEIXZ ENDP		; ChunkAllocator::getChunkNum
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\tim23\Documents\Visual Studio 2019\Projects\Project2D\Project2D\MemoryManager\Allocators\ChunkAllocator.h
;	COMDAT ?getChunkSize@ChunkAllocator@@UBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getChunkSize@ChunkAllocator@@UBEIXZ PROC		; ChunkAllocator::getChunkSize, COMDAT
; _this$ = ecx

; 50   : 	virtual size_t getChunkSize() const { return chunkSize; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __3F31CF21_ChunkAllocator@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?getChunkSize@ChunkAllocator@@UBEIXZ ENDP		; ChunkAllocator::getChunkSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\tim23\Documents\Visual Studio 2019\Projects\Project2D\Project2D\MemoryManager\Allocators\ChunkAllocator.h
;	COMDAT ?getUsingSectorsNum@ChunkAllocator@@UBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getUsingSectorsNum@ChunkAllocator@@UBEIXZ PROC		; ChunkAllocator::getUsingSectorsNum, COMDAT
; _this$ = ecx

; 48   : 	virtual size_t getUsingSectorsNum() const { return usingSectorsNum; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __3F31CF21_ChunkAllocator@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?getUsingSectorsNum@ChunkAllocator@@UBEIXZ ENDP		; ChunkAllocator::getUsingSectorsNum
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\tim23\Documents\Visual Studio 2019\Projects\Project2D\Project2D\MemoryManager\Allocators\ChunkAllocator.h
;	COMDAT ?size@ChunkAllocator@@UBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@ChunkAllocator@@UBEIXZ PROC			; ChunkAllocator::size, COMDAT
; _this$ = ecx

; 47   : 	virtual size_t size() const { return usingChunksNum; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __3F31CF21_ChunkAllocator@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?size@ChunkAllocator@@UBEIXZ ENDP			; ChunkAllocator::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\tim23\Documents\Visual Studio 2019\Projects\Project2D\Project2D\MemoryManager\Allocators\ChunkAllocator.h
;	COMDAT ?getHeap@ChunkAllocator@@UAEPAVHeap@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getHeap@ChunkAllocator@@UAEPAVHeap@@XZ PROC		; ChunkAllocator::getHeap, COMDAT
; _this$ = ecx

; 45   : 	virtual Heap* getHeap() { return heap; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __3F31CF21_ChunkAllocator@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?getHeap@ChunkAllocator@@UAEPAVHeap@@XZ ENDP		; ChunkAllocator::getHeap
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\tim23\Documents\Visual Studio 2019\Projects\Project2D\Project2D\MemoryManager\Allocators\ChunkAllocator.cpp
;	COMDAT ?clean@ChunkAllocator@@UAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?clean@ChunkAllocator@@UAEXXZ PROC			; ChunkAllocator::clean, COMDAT
; _this$ = ecx

; 155  : void ChunkAllocator::clean() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __F42B12D8_ChunkAllocator@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 156  :     firstFreeSector = (SectorInfo*)chunks;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+12], edx

; 157  :     firstFreeSector->isFree = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	BYTE PTR [ecx+20], 1

; 158  :     firstFreeSector->nextSector = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+4], 0

; 159  :     firstFreeSector->prevSector = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+8], 0

; 160  :     firstFreeSector->nextFreeSector = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], 0

; 161  :     firstFreeSector->prevFreeSector = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+16], 0

; 162  :     firstFreeSector->chunksNum = chunksNum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx], eax

; 163  : 
; 164  :     usingChunksNum = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 165  :     usingSectorsNum = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 166  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?clean@ChunkAllocator@@UAEXXZ ENDP			; ChunkAllocator::clean
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\tim23\Documents\Visual Studio 2019\Projects\Project2D\Project2D\MemoryManager\Allocators\ChunkAllocator.cpp
;	COMDAT ?deallocate@ChunkAllocator@@UAEXPAX@Z
_TEXT	SEGMENT
_nearSector$ = -32					; size = 4
_currentSectionInfo$ = -20				; size = 4
_this$ = -8						; size = 4
_sector$ = 8						; size = 4
?deallocate@ChunkAllocator@@UAEXPAX@Z PROC		; ChunkAllocator::deallocate, COMDAT
; _this$ = ecx

; 128  : void ChunkAllocator::deallocate(void* sector) {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __F42B12D8_ChunkAllocator@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 129  :     SectorInfo* currentSectionInfo = (SectorInfo*)((uint8_t*)sector - sizeof(SectorInfo));

	mov	eax, DWORD PTR _sector$[ebp]
	sub	eax, 24					; 00000018H
	mov	DWORD PTR _currentSectionInfo$[ebp], eax

; 130  : 
; 131  :     currentSectionInfo->isFree = true;

	mov	eax, DWORD PTR _currentSectionInfo$[ebp]
	mov	BYTE PTR [eax+20], 1

; 132  :     usingChunksNum -= currentSectionInfo->chunksNum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _currentSectionInfo$[ebp]
	mov	edx, DWORD PTR [eax+16]
	sub	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], edx

; 133  : 
; 134  :     SectorInfo* nearSector = currentSectionInfo->prevSector;

	mov	eax, DWORD PTR _currentSectionInfo$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _nearSector$[ebp], ecx

; 135  :     if (nearSector && nearSector->isFree) {

	cmp	DWORD PTR _nearSector$[ebp], 0
	je	SHORT $LN2@deallocate
	mov	eax, DWORD PTR _nearSector$[ebp]
	movzx	ecx, BYTE PTR [eax+20]
	test	ecx, ecx
	je	SHORT $LN2@deallocate

; 136  :         nearSector->nextSector = currentSectionInfo->nextSector;

	mov	eax, DWORD PTR _nearSector$[ebp]
	mov	ecx, DWORD PTR _currentSectionInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 137  :         nearSector->chunksNum += currentSectionInfo->chunksNum;

	mov	eax, DWORD PTR _nearSector$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _currentSectionInfo$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR _nearSector$[ebp]
	mov	DWORD PTR [eax], ecx

; 138  : 
; 139  :         currentSectionInfo = nearSector;

	mov	eax, DWORD PTR _nearSector$[ebp]
	mov	DWORD PTR _currentSectionInfo$[ebp], eax
$LN2@deallocate:

; 140  :     }
; 141  : 
; 142  :     nearSector = currentSectionInfo->nextSector;

	mov	eax, DWORD PTR _currentSectionInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _nearSector$[ebp], ecx

; 143  :     if (nearSector && nearSector->isFree) {

	cmp	DWORD PTR _nearSector$[ebp], 0
	je	SHORT $LN3@deallocate
	mov	eax, DWORD PTR _nearSector$[ebp]
	movzx	ecx, BYTE PTR [eax+20]
	test	ecx, ecx
	je	SHORT $LN3@deallocate

; 144  :         currentSectionInfo->nextSector = nearSector->nextSector;

	mov	eax, DWORD PTR _currentSectionInfo$[ebp]
	mov	ecx, DWORD PTR _nearSector$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 145  :         currentSectionInfo->nextFreeSector = nearSector->nextFreeSector;

	mov	eax, DWORD PTR _currentSectionInfo$[ebp]
	mov	ecx, DWORD PTR _nearSector$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 146  :         currentSectionInfo->chunksNum += nearSector->chunksNum;

	mov	eax, DWORD PTR _currentSectionInfo$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _nearSector$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR _currentSectionInfo$[ebp]
	mov	DWORD PTR [eax], ecx

; 147  : 
; 148  :         if (nearSector == firstFreeSector)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nearSector$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jne	SHORT $LN3@deallocate

; 149  :             firstFreeSector = currentSectionInfo;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _currentSectionInfo$[ebp]
	mov	DWORD PTR [eax+12], ecx
$LN3@deallocate:

; 150  :     }
; 151  : 
; 152  :     --usingSectorsNum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 153  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?deallocate@ChunkAllocator@@UAEXPAX@Z ENDP		; ChunkAllocator::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\tim23\Documents\Visual Studio 2019\Projects\Project2D\Project2D\MemoryManager\Allocators\ChunkAllocator.cpp
;	COMDAT ?allocate@ChunkAllocator@@UAEPAXI@Z
_TEXT	SEGMENT
tv161 = -288						; size = 8
tv157 = -280						; size = 4
tv151 = -276						; size = 8
tv147 = -268						; size = 4
_newSectorInfo$1 = -68					; size = 4
_currentSectorInfo$2 = -56				; size = 4
_requiringChunks$ = -44					; size = 4
_requiringSize$ = -32					; size = 4
_requiringSector$ = -20					; size = 4
_this$ = -8						; size = 4
_size$ = 8						; size = 4
?allocate@ChunkAllocator@@UAEPAXI@Z PROC		; ChunkAllocator::allocate, COMDAT
; _this$ = ecx

; 85   : void* ChunkAllocator::allocate(size_t size) {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 72					; 00000048H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __F42B12D8_ChunkAllocator@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 86   :     void* requiringSector = nullptr;

	mov	DWORD PTR _requiringSector$[ebp], 0

; 87   : 
; 88   :     size_t requiringSize = size + sizeof(SectorInfo);

	mov	eax, DWORD PTR _size$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR _requiringSize$[ebp], eax

; 89   :     size_t requiringChunks = (size_t)ceilf(requiringSize / (float)chunkSize);

	mov	eax, DWORD PTR _requiringSize$[ebp]
	mov	DWORD PTR tv147[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv147[ebp]
	mov	ecx, DWORD PTR tv147[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv151[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv151[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR tv157[ebp], eax
	cvtsi2sd xmm1, DWORD PTR tv157[ebp]
	mov	ecx, DWORD PTR tv157[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv161[ebp], xmm1
	cvtsd2ss xmm1, QWORD PTR tv161[ebp]
	divss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_ceilf
	add	esp, 4
	call	__ftol2
	mov	DWORD PTR _requiringChunks$[ebp], eax

; 90   : 
; 91   :     if (requiringChunks < chunksNum - usingChunksNum) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+28]
	sub	edx, DWORD PTR [ecx+16]
	cmp	DWORD PTR _requiringChunks$[ebp], edx
	jae	$LN4@allocate

; 92   :         SectorInfo* currentSectorInfo = firstFreeSector;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _currentSectorInfo$2[ebp], ecx
$LN2@allocate:

; 93   : 
; 94   :         while (currentSectorInfo->chunksNum < requiringChunks) {

	mov	eax, DWORD PTR _currentSectorInfo$2[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _requiringChunks$[ebp]
	jae	SHORT $LN3@allocate

; 95   :             if (currentSectorInfo->nextFreeSector == nullptr)

	mov	eax, DWORD PTR _currentSectorInfo$2[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN5@allocate

; 96   :                 return requiringSector;

	mov	eax, DWORD PTR _requiringSector$[ebp]
	jmp	$LN1@allocate
	jmp	SHORT $LN6@allocate
$LN5@allocate:

; 97   :             else
; 98   :                 currentSectorInfo = currentSectorInfo->nextFreeSector;

	mov	eax, DWORD PTR _currentSectorInfo$2[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _currentSectorInfo$2[ebp], ecx
$LN6@allocate:

; 99   :         }

	jmp	SHORT $LN2@allocate
$LN3@allocate:

; 100  : 
; 101  :         SectorInfo* newSectorInfo = (SectorInfo*)(((uint8_t*)currentSectorInfo + requiringSize));

	mov	eax, DWORD PTR _currentSectorInfo$2[ebp]
	add	eax, DWORD PTR _requiringSize$[ebp]
	mov	DWORD PTR _newSectorInfo$1[ebp], eax

; 102  : 
; 103  :         newSectorInfo->isFree = true;

	mov	eax, DWORD PTR _newSectorInfo$1[ebp]
	mov	BYTE PTR [eax+20], 1

; 104  :         newSectorInfo->nextSector = currentSectorInfo->nextSector;

	mov	eax, DWORD PTR _newSectorInfo$1[ebp]
	mov	ecx, DWORD PTR _currentSectorInfo$2[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 105  :         newSectorInfo->prevSector = currentSectorInfo;

	mov	eax, DWORD PTR _newSectorInfo$1[ebp]
	mov	ecx, DWORD PTR _currentSectorInfo$2[ebp]
	mov	DWORD PTR [eax+8], ecx

; 106  :         newSectorInfo->nextFreeSector = currentSectorInfo->nextFreeSector;

	mov	eax, DWORD PTR _newSectorInfo$1[ebp]
	mov	ecx, DWORD PTR _currentSectorInfo$2[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 107  :         newSectorInfo->prevFreeSector = currentSectorInfo->prevFreeSector;

	mov	eax, DWORD PTR _newSectorInfo$1[ebp]
	mov	ecx, DWORD PTR _currentSectorInfo$2[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 108  :         newSectorInfo->chunksNum = currentSectorInfo->chunksNum - requiringChunks;

	mov	eax, DWORD PTR _currentSectorInfo$2[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR _requiringChunks$[ebp]
	mov	edx, DWORD PTR _newSectorInfo$1[ebp]
	mov	DWORD PTR [edx], ecx

; 109  : 
; 110  :         currentSectorInfo->nextSector = newSectorInfo;

	mov	eax, DWORD PTR _currentSectorInfo$2[ebp]
	mov	ecx, DWORD PTR _newSectorInfo$1[ebp]
	mov	DWORD PTR [eax+4], ecx

; 111  :         currentSectorInfo->chunksNum = requiringChunks;

	mov	eax, DWORD PTR _currentSectorInfo$2[ebp]
	mov	ecx, DWORD PTR _requiringChunks$[ebp]
	mov	DWORD PTR [eax], ecx

; 112  : 
; 113  :         firstFreeSector = newSectorInfo;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newSectorInfo$1[ebp]
	mov	DWORD PTR [eax+12], ecx

; 114  : 
; 115  :         if (currentSectorInfo->prevFreeSector)

	mov	eax, DWORD PTR _currentSectorInfo$2[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN7@allocate

; 116  :             currentSectorInfo->prevFreeSector->nextFreeSector = currentSectorInfo->nextFreeSector;

	mov	eax, DWORD PTR _currentSectorInfo$2[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _currentSectorInfo$2[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
$LN7@allocate:

; 117  : 
; 118  :         currentSectorInfo->isFree = false;

	mov	eax, DWORD PTR _currentSectorInfo$2[ebp]
	mov	BYTE PTR [eax+20], 0

; 119  :         requiringSector = (uint8_t*)currentSectorInfo + sizeof(SectorInfo);

	mov	eax, DWORD PTR _currentSectorInfo$2[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR _requiringSector$[ebp], eax

; 120  : 
; 121  :         usingChunksNum += requiringChunks;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, DWORD PTR _requiringChunks$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 122  :         ++usingSectorsNum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx
$LN4@allocate:

; 123  :     }
; 124  : 
; 125  :     return requiringSector;

	mov	eax, DWORD PTR _requiringSector$[ebp]
$LN1@allocate:

; 126  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@ChunkAllocator@@UAEPAXI@Z ENDP		; ChunkAllocator::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\tim23\Documents\Visual Studio 2019\Projects\Project2D\Project2D\MemoryManager\Allocators\ChunkAllocator.cpp
;	COMDAT ?release@ChunkAllocator@@UAEXXZ
_TEXT	SEGMENT
tv71 = -208						; size = 4
_this$ = -8						; size = 4
?release@ChunkAllocator@@UAEXXZ PROC			; ChunkAllocator::release, COMDAT
; _this$ = ecx

; 69   : void ChunkAllocator::release() {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __F42B12D8_ChunkAllocator@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 70   :     if (chunks) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN2@release

; 71   :         heap->deallocate(chunks);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv71[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR tv71[ebp]
	call	?deallocate@Heap@@QAEXPAX@Z		; Heap::deallocate

; 72   :         chunks = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
$LN2@release:

; 73   :     }
; 74   : 
; 75   :     heap = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 76   :     firstFreeSector = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 77   : 
; 78   :     usingChunksNum = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 79   :     usingSectorsNum = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 80   : 
; 81   :     chunkSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 82   :     chunksNum = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 83   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?release@ChunkAllocator@@UAEXXZ ENDP			; ChunkAllocator::release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\tim23\Documents\Visual Studio 2019\Projects\Project2D\Project2D\MemoryManager\Allocators\ChunkAllocator.cpp
;	COMDAT ?init@ChunkAllocator@@UAE_NPAVHeap@@II@Z
_TEXT	SEGMENT
_requiredSize$ = -20					; size = 4
_this$ = -8						; size = 4
__heap$ = 8						; size = 4
__chunkSize$ = 12					; size = 4
__chunksNum$ = 16					; size = 4
?init@ChunkAllocator@@UAE_NPAVHeap@@II@Z PROC		; ChunkAllocator::init, COMDAT
; _this$ = ecx

; 54   : bool ChunkAllocator::init(Heap* _heap, size_t _chunkSize, size_t _chunksNum) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __F42B12D8_ChunkAllocator@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 55   :     size_t requiredSize = (_chunkSize + sizeof(SectorInfo)) * _chunksNum;

	mov	eax, DWORD PTR __chunkSize$[ebp]
	add	eax, 24					; 00000018H
	imul	eax, DWORD PTR __chunksNum$[ebp]
	mov	DWORD PTR _requiredSize$[ebp], eax

; 56   :     chunks = _heap->allocate(requiredSize);

	mov	eax, DWORD PTR _requiredSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __heap$[ebp]
	call	?allocate@Heap@@QAEPAXI@Z		; Heap::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 57   :     if (!chunks) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@init

; 58   :         return false;

	xor	al, al
	jmp	SHORT $LN1@init
$LN2@init:

; 59   :     }
; 60   : 
; 61   :     heap = _heap;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __heap$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 62   : 
; 63   :     chunkSize = _chunkSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __chunkSize$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 64   :     chunksNum = _chunksNum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __chunksNum$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 65   : 
; 66   :     return true;

	mov	al, 1
$LN1@init:

; 67   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?init@ChunkAllocator@@UAE_NPAVHeap@@II@Z ENDP		; ChunkAllocator::init
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\tim23\Documents\Visual Studio 2019\Projects\Project2D\Project2D\MemoryManager\Allocators\ChunkAllocator.cpp
;	COMDAT ??4ChunkAllocator@@QAEAAV0@$$QAV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_allocator$ = 8						; size = 4
??4ChunkAllocator@@QAEAAV0@$$QAV0@@Z PROC		; ChunkAllocator::operator=, COMDAT
; _this$ = ecx

; 33   : ChunkAllocator& ChunkAllocator::operator=(ChunkAllocator&& allocator) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __F42B12D8_ChunkAllocator@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 34   :     release();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 35   : 
; 36   :     heap = allocator.heap;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _allocator$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 37   :     chunks = allocator.chunks;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _allocator$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 38   :     firstFreeSector = allocator.firstFreeSector;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _allocator$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 39   :     usingChunksNum = allocator.usingChunksNum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _allocator$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 40   :     usingSectorsNum = allocator.usingSectorsNum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _allocator$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx

; 41   :     chunkSize = allocator.chunkSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _allocator$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx

; 42   :     chunksNum = allocator.chunksNum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _allocator$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx

; 43   : 
; 44   :     allocator.heap = nullptr;

	mov	eax, DWORD PTR _allocator$[ebp]
	mov	DWORD PTR [eax+4], 0

; 45   :     allocator.chunks = nullptr;

	mov	eax, DWORD PTR _allocator$[ebp]
	mov	DWORD PTR [eax+8], 0

; 46   :     allocator.firstFreeSector = nullptr;

	mov	eax, DWORD PTR _allocator$[ebp]
	mov	DWORD PTR [eax+12], 0

; 47   :     allocator.usingChunksNum = 0;

	mov	eax, DWORD PTR _allocator$[ebp]
	mov	DWORD PTR [eax+16], 0

; 48   :     allocator.chunkSize = 0;

	mov	eax, DWORD PTR _allocator$[ebp]
	mov	DWORD PTR [eax+24], 0

; 49   :     allocator.chunksNum = 0;

	mov	eax, DWORD PTR _allocator$[ebp]
	mov	DWORD PTR [eax+28], 0

; 50   : 
; 51   :     return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 52   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4ChunkAllocator@@QAEAAV0@$$QAV0@@Z ENDP		; ChunkAllocator::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\tim23\Documents\Visual Studio 2019\Projects\Project2D\Project2D\MemoryManager\Allocators\ChunkAllocator.h
;	COMDAT ??1ChunkAllocator@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1ChunkAllocator@@UAE@XZ PROC				; ChunkAllocator::~ChunkAllocator, COMDAT
; _this$ = ecx

; 32   : 	virtual ~ChunkAllocator() { ChunkAllocator::release(); }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1ChunkAllocator@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __3F31CF21_ChunkAllocator@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7ChunkAllocator@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?release@ChunkAllocator@@UAEXXZ		; ChunkAllocator::release
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1ChunkAllocator@@UAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1ChunkAllocator@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1ChunkAllocator@@UAE@XZ ENDP				; ChunkAllocator::~ChunkAllocator
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\tim23\Documents\Visual Studio 2019\Projects\Project2D\Project2D\MemoryManager\Allocators\ChunkAllocator.cpp
;	COMDAT ??0ChunkAllocator@@QAE@$$QAV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_allocator$ = 8						; size = 4
??0ChunkAllocator@@QAE@$$QAV0@@Z PROC			; ChunkAllocator::ChunkAllocator, COMDAT
; _this$ = ecx

; 16   : ChunkAllocator::ChunkAllocator(ChunkAllocator&& allocator) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __F42B12D8_ChunkAllocator@cpp
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7ChunkAllocator@@6B@

; 17   :     heap = allocator.heap;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _allocator$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 18   :     chunks = allocator.chunks;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _allocator$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 19   :     firstFreeSector = allocator.firstFreeSector;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _allocator$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 20   :     usingChunksNum = allocator.usingChunksNum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _allocator$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 21   :     usingSectorsNum = allocator.usingSectorsNum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _allocator$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx

; 22   :     chunkSize = allocator.chunkSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _allocator$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx

; 23   :     chunksNum = allocator.chunksNum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _allocator$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx

; 24   : 
; 25   :     allocator.heap = nullptr;

	mov	eax, DWORD PTR _allocator$[ebp]
	mov	DWORD PTR [eax+4], 0

; 26   :     allocator.chunks = nullptr;

	mov	eax, DWORD PTR _allocator$[ebp]
	mov	DWORD PTR [eax+8], 0

; 27   :     allocator.firstFreeSector = nullptr;

	mov	eax, DWORD PTR _allocator$[ebp]
	mov	DWORD PTR [eax+12], 0

; 28   :     allocator.usingChunksNum = 0;

	mov	eax, DWORD PTR _allocator$[ebp]
	mov	DWORD PTR [eax+16], 0

; 29   :     allocator.chunkSize = 0;

	mov	eax, DWORD PTR _allocator$[ebp]
	mov	DWORD PTR [eax+24], 0

; 30   :     allocator.chunksNum = 0;

	mov	eax, DWORD PTR _allocator$[ebp]
	mov	DWORD PTR [eax+28], 0

; 31   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0ChunkAllocator@@QAE@$$QAV0@@Z ENDP			; ChunkAllocator::ChunkAllocator
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\tim23\Documents\Visual Studio 2019\Projects\Project2D\Project2D\MemoryManager\Allocators\ChunkAllocator.cpp
;	COMDAT ??0ChunkAllocator@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0ChunkAllocator@@QAE@XZ PROC				; ChunkAllocator::ChunkAllocator, COMDAT
; _this$ = ecx

; 13   :     usingChunksNum(0), usingSectorsNum(0), chunkSize(0), chunksNum(0) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __F42B12D8_ChunkAllocator@cpp
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7ChunkAllocator@@6B@

; 12   :     : heap(nullptr), chunks(nullptr), firstFreeSector(nullptr),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 13   :     usingChunksNum(0), usingSectorsNum(0), chunkSize(0), chunksNum(0) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 14   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0ChunkAllocator@@QAE@XZ ENDP				; ChunkAllocator::ChunkAllocator
_TEXT	ENDS
END
