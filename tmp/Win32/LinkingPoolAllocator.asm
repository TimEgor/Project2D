; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	C:\Users\tim23\Documents\Visual Studio 2019\Projects\Project2D\Project2D\MemoryManager\Allocators\LinkingPoolAllocator.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__BE586046_PoolAllocator@h DB 01H
__D79E3112_LinkingPoolAllocator@h DB 01H
__B2D2BA86_ctype@h DB 01H
__79C7FC57_basetsd@h DB 01H
__1FEB9909_corecrt_memcpy_s@h DB 01H
__A751F051_corecrt_memory@h DB 01H
__9200769A_corecrt_wstring@h DB 01H
__32E5F013_string@h DB 01H
__D545DD43_guiddef@h DB 01H
__D5DDFBF3_winnt@h DB 01H
__439612F0_processthreadsapi@h DB 01H
__5733279A_memoryapi@h DB 01H
__D4435474_winerror@h DB 01H
__B3ED30D4_winbase@h DB 01H
__DB057BA3_winuser@h DB 01H
__A7113148_winioctl@h DB 01H
__B49664B7_stdlib@h DB 01H
__EC5BC72C_propidl@h DB 01H
__6DA674A0_oleauto@h DB 01H
__A118E6DC_stralign@h DB 01H
__1E01F8EA_Heap@h DB 01H
__8B404B8B_vcruntime_new@h DB 01H
__4C8DB69C_cstddef DB 01H
__741AE07E_corecrt_math@h DB 01H
__E9466C31_cstdlib DB 01H
__77E6CA79_type_traits DB 01H
__20BB4341_malloc@h DB 01H
__604808BE_vcruntime_exception@h DB 01H
__8655F6A9_exception DB 01H
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__C6E16F6F_corecrt_wconio@h DB 01H
__6D390390_corecrt_wio@h DB 01H
__1157D6BA_corecrt_wtime@h DB 01H
__1DC1E279_stat@h DB 01H
__93DC0B45_wchar@h DB 01H
__EC89C42C_vcruntime_typeinfo@h DB 01H
__AE3815F6_typeinfo DB 01H
__A47FD3F7_limits DB 01H
__DEE7E6EF_xutility DB 01H
__B4DE8A79_xmemory DB 01H
__18D1DF79_memory DB 01H
__5A45405C_LinkingPoolAllocator@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?init@LinkingPoolAllocator@@UAE_NPAVHeap@@II@Z	; LinkingPoolAllocator::init
PUBLIC	?clear@LinkingPoolAllocator@@UAEXXZ		; LinkingPoolAllocator::clear
PUBLIC	?allocate@LinkingPoolAllocator@@UAEPAXXZ	; LinkingPoolAllocator::allocate
PUBLIC	?deallocate@LinkingPoolAllocator@@UAEXPAX@Z	; LinkingPoolAllocator::deallocate
PUBLIC	__JustMyCode_Default
PUBLIC	?__LINE__Var@?0??init@LinkingPoolAllocator@@UAE_NPAVHeap@@II@Z@4JA ; `LinkingPoolAllocator::init'::`1'::__LINE__Var
PUBLIC	??_C@_1PG@KGIOLBMI@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAt?$AAi?$AAm?$AA2?$AA3?$AA?2@ ; `string'
PUBLIC	??_C@_1FI@OPHLMCIO@?$AAr?$AAe?$AAq?$AAu?$AAi?$AAr?$AAe?$AAd?$AAB?$AAu?$AAc?$AAk?$AAe?$AAt?$AAS@ ; `string'
EXTRN	?deallocate@PoolAllocator@@UAEXPAX@Z:PROC	; PoolAllocator::deallocate
EXTRN	?clear@PoolAllocator@@UAEXXZ:PROC		; PoolAllocator::clear
EXTRN	?allocate@Heap@@QAEPAXI@Z:PROC			; Heap::allocate
EXTRN	__imp___wassert:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1FI@OPHLMCIO@?$AAr?$AAe?$AAq?$AAu?$AAi?$AAr?$AAe?$AAd?$AAB?$AAu?$AAc?$AAk?$AAe?$AAt?$AAS@
CONST	SEGMENT
??_C@_1FI@OPHLMCIO@?$AAr?$AAe?$AAq?$AAu?$AAi?$AAr?$AAe?$AAd?$AAB?$AAu?$AAc?$AAk?$AAe?$AAt?$AAS@ DB 'r'
	DB	00H, 'e', 00H, 'q', 00H, 'u', 00H, 'i', 00H, 'r', 00H, 'e', 00H
	DB	'd', 00H, 'B', 00H, 'u', 00H, 'c', 00H, 'k', 00H, 'e', 00H, 't'
	DB	00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '>', 00H
	DB	' ', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 'o', 00H, 'f'
	DB	00H, '(', 00H, 'F', 00H, 'r', 00H, 'e', 00H, 'e', 00H, 'B', 00H
	DB	'u', 00H, 'c', 00H, 'k', 00H, 'e', 00H, 't', 00H, 'I', 00H, 'n'
	DB	00H, 'f', 00H, 'o', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1PG@KGIOLBMI@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAt?$AAi?$AAm?$AA2?$AA3?$AA?2@
CONST	SEGMENT
??_C@_1PG@KGIOLBMI@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAt?$AAi?$AAm?$AA2?$AA3?$AA?2@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'U', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '\', 00H, 't', 00H, 'i', 00H, 'm', 00H, '2', 00H, '3'
	DB	00H, '\', 00H, 'D', 00H, 'o', 00H, 'c', 00H, 'u', 00H, 'm', 00H
	DB	'e', 00H, 'n', 00H, 't', 00H, 's', 00H, '\', 00H, 'V', 00H, 'i'
	DB	00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' ', 00H, 'S', 00H
	DB	't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H, '2'
	DB	00H, '0', 00H, '1', 00H, '9', 00H, '\', 00H, 'P', 00H, 'r', 00H
	DB	'o', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 's', 00H, '\'
	DB	00H, 'P', 00H, 'r', 00H, 'o', 00H, 'j', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, '2', 00H, 'D', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o'
	DB	00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, '2', 00H, 'D', 00H
	DB	'\', 00H, 'M', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y'
	DB	00H, 'M', 00H, 'a', 00H, 'n', 00H, 'a', 00H, 'g', 00H, 'e', 00H
	DB	'r', 00H, '\', 00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, 's', 00H, '\', 00H
	DB	'L', 00H, 'i', 00H, 'n', 00H, 'k', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, 'P', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 'A', 00H, 'l', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '.', 00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??init@LinkingPoolAllocator@@UAE_NPAVHeap@@II@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??init@LinkingPoolAllocator@@UAE_NPAVHeap@@II@Z@4JA DD 0aH ; `LinkingPoolAllocator::init'::`1'::__LINE__Var
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\tim23\Documents\Visual Studio 2019\Projects\Project2D\Project2D\MemoryManager\Allocators\LinkingPoolAllocator.cpp
;	COMDAT ?deallocate@LinkingPoolAllocator@@UAEXPAX@Z
_TEXT	SEGMENT
_nextBucketInfo$1 = -44					; size = 4
_prevBucketInfo$2 = -32					; size = 4
_currentBuckerInfo$ = -20				; size = 4
_this$ = -8						; size = 4
_bucket$ = 8						; size = 4
?deallocate@LinkingPoolAllocator@@UAEXPAX@Z PROC	; LinkingPoolAllocator::deallocate, COMDAT
; _this$ = ecx

; 75   : void LinkingPoolAllocator::deallocate(void* bucket) {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __5A45405C_LinkingPoolAllocator@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 76   :     UsingBucketInfo* currentBuckerInfo = (UsingBucketInfo*)((uint8_t*)bucket + bucketSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _bucket$[ebp]
	add	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _currentBuckerInfo$[ebp], ecx

; 77   :     if (bucket != buckets) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _bucket$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	je	SHORT $LN2@deallocate

; 78   :         UsingBucketInfo* prevBucketInfo = (UsingBucketInfo*)((uint8_t*)bucket - sizeof(UsingBucketInfo*));

	mov	eax, DWORD PTR _bucket$[ebp]
	sub	eax, 4
	mov	DWORD PTR _prevBucketInfo$2[ebp], eax

; 79   :         prevBucketInfo->nextBucket = currentBuckerInfo->nextBucket;

	mov	eax, DWORD PTR _prevBucketInfo$2[ebp]
	mov	ecx, DWORD PTR _currentBuckerInfo$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN2@deallocate:

; 80   :     }
; 81   : 
; 82   :     if (currentBuckerInfo != lastBucketInfo) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _currentBuckerInfo$[ebp]
	cmp	ecx, DWORD PTR [eax+28]
	je	SHORT $LN3@deallocate

; 83   :         UsingBucketInfo* nextBucketInfo = (UsingBucketInfo*)((uint8_t*)currentBuckerInfo + sizeof(UsingBucketInfo*) + bucketSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _currentBuckerInfo$[ebp]
	lea	eax, DWORD PTR [edx+ecx+4]
	mov	DWORD PTR _nextBucketInfo$1[ebp], eax

; 84   :         nextBucketInfo->prevBucket = currentBuckerInfo->prevBucket;

	mov	eax, DWORD PTR _nextBucketInfo$1[ebp]
	mov	ecx, DWORD PTR _currentBuckerInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
$LN3@deallocate:

; 85   :     }
; 86   : 
; 87   :     if (currentBuckerInfo == firstUsingBucketInfo) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _currentBuckerInfo$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jne	SHORT $LN4@deallocate

; 88   :         firstUsingBucketInfo = firstUsingBucketInfo->nextBucket;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+32], eax
$LN4@deallocate:

; 89   :     }
; 90   : 
; 91   :     PoolAllocator::deallocate(bucket);

	mov	eax, DWORD PTR _bucket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@PoolAllocator@@UAEXPAX@Z	; PoolAllocator::deallocate

; 92   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?deallocate@LinkingPoolAllocator@@UAEXPAX@Z ENDP	; LinkingPoolAllocator::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\tim23\Documents\Visual Studio 2019\Projects\Project2D\Project2D\MemoryManager\Allocators\LinkingPoolAllocator.cpp
;	COMDAT ?allocate@LinkingPoolAllocator@@UAEPAXXZ
_TEXT	SEGMENT
_nextBucketInfo$1 = -56					; size = 4
_prevBucketInfo$2 = -44					; size = 4
_currentBuckerInfo$3 = -32				; size = 4
_requiringBucket$ = -20					; size = 4
_this$ = -8						; size = 4
?allocate@LinkingPoolAllocator@@UAEPAXXZ PROC		; LinkingPoolAllocator::allocate, COMDAT
; _this$ = ecx

; 37   : void* LinkingPoolAllocator::allocate() {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __5A45405C_LinkingPoolAllocator@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 38   :     void* requiringBucket = nullptr;

	mov	DWORD PTR _requiringBucket$[ebp], 0

; 39   : 
; 40   :     if (firstFreeBucket) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	$LN2@allocate

; 41   :         requiringBucket = firstFreeBucket;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _requiringBucket$[ebp], ecx

; 42   :         firstFreeBucket = firstFreeBucket->nextFree;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+12], eax

; 43   : 
; 44   :         ++usingBucketsNum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 45   : 
; 46   :         UsingBucketInfo* currentBuckerInfo = (UsingBucketInfo*)((uint8_t*)requiringBucket + bucketSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _requiringBucket$[ebp]
	add	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _currentBuckerInfo$3[ebp], ecx

; 47   :         currentBuckerInfo->nextBucket = nullptr;

	mov	eax, DWORD PTR _currentBuckerInfo$3[ebp]
	mov	DWORD PTR [eax], 0

; 48   :         currentBuckerInfo->prevBucket = nullptr;

	mov	eax, DWORD PTR _currentBuckerInfo$3[ebp]
	mov	DWORD PTR [eax+4], 0

; 49   : 
; 50   :         if (requiringBucket != buckets) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _requiringBucket$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	je	SHORT $LN3@allocate

; 51   :             UsingBucketInfo* prevBucketInfo = (UsingBucketInfo*)((uint8_t*)requiringBucket - sizeof(UsingBucketInfo*));

	mov	eax, DWORD PTR _requiringBucket$[ebp]
	sub	eax, 4
	mov	DWORD PTR _prevBucketInfo$2[ebp], eax

; 52   :             currentBuckerInfo->prevBucket = prevBucketInfo;

	mov	eax, DWORD PTR _currentBuckerInfo$3[ebp]
	mov	ecx, DWORD PTR _prevBucketInfo$2[ebp]
	mov	DWORD PTR [eax+4], ecx

; 53   :             prevBucketInfo->nextBucket = currentBuckerInfo;

	mov	eax, DWORD PTR _prevBucketInfo$2[ebp]
	mov	ecx, DWORD PTR _currentBuckerInfo$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@allocate:

; 54   :         }
; 55   : 
; 56   :         if (currentBuckerInfo != lastBucketInfo) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _currentBuckerInfo$3[ebp]
	cmp	ecx, DWORD PTR [eax+28]
	je	SHORT $LN4@allocate

; 57   :             UsingBucketInfo* nextBucketInfo = (UsingBucketInfo*)((uint8_t*)currentBuckerInfo + sizeof(UsingBucketInfo*) + bucketSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _currentBuckerInfo$3[ebp]
	lea	eax, DWORD PTR [edx+ecx+4]
	mov	DWORD PTR _nextBucketInfo$1[ebp], eax

; 58   :             currentBuckerInfo->nextBucket = nextBucketInfo;

	mov	eax, DWORD PTR _currentBuckerInfo$3[ebp]
	mov	ecx, DWORD PTR _nextBucketInfo$1[ebp]
	mov	DWORD PTR [eax], ecx

; 59   :             nextBucketInfo->prevBucket = currentBuckerInfo;

	mov	eax, DWORD PTR _nextBucketInfo$1[ebp]
	mov	ecx, DWORD PTR _currentBuckerInfo$3[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN4@allocate:

; 60   :         }
; 61   : 
; 62   :         if (firstUsingBucketInfo) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN5@allocate

; 63   :             if (currentBuckerInfo < firstUsingBucketInfo) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _currentBuckerInfo$3[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jae	SHORT $LN7@allocate

; 64   :                 firstUsingBucketInfo = currentBuckerInfo;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _currentBuckerInfo$3[ebp]
	mov	DWORD PTR [eax+32], ecx
$LN7@allocate:

; 65   :             }
; 66   :         }

	jmp	SHORT $LN2@allocate
$LN5@allocate:

; 67   :         else {
; 68   :             firstUsingBucketInfo = currentBuckerInfo;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _currentBuckerInfo$3[ebp]
	mov	DWORD PTR [eax+32], ecx
$LN2@allocate:

; 69   :         }
; 70   :     }
; 71   : 
; 72   :     return requiringBucket;

	mov	eax, DWORD PTR _requiringBucket$[ebp]

; 73   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?allocate@LinkingPoolAllocator@@UAEPAXXZ ENDP		; LinkingPoolAllocator::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\tim23\Documents\Visual Studio 2019\Projects\Project2D\Project2D\MemoryManager\Allocators\LinkingPoolAllocator.cpp
;	COMDAT ?clear@LinkingPoolAllocator@@UAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?clear@LinkingPoolAllocator@@UAEXXZ PROC		; LinkingPoolAllocator::clear, COMDAT
; _this$ = ecx

; 31   : void LinkingPoolAllocator::clear() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __5A45405C_LinkingPoolAllocator@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 32   :     firstUsingBucketInfo = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0

; 33   : 
; 34   :     PoolAllocator::clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@PoolAllocator@@UAEXXZ		; PoolAllocator::clear

; 35   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?clear@LinkingPoolAllocator@@UAEXXZ ENDP		; LinkingPoolAllocator::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\tim23\Documents\Visual Studio 2019\Projects\Project2D\Project2D\MemoryManager\Allocators\LinkingPoolAllocator.cpp
;	COMDAT ?init@LinkingPoolAllocator@@UAE_NPAVHeap@@II@Z
_TEXT	SEGMENT
_requiredSize$ = -32					; size = 4
_requiredBucketSize$ = -20				; size = 4
_this$ = -8						; size = 4
__heap$ = 8						; size = 4
__bucketSize$ = 12					; size = 4
__bucketsNum$ = 16					; size = 4
?init@LinkingPoolAllocator@@UAE_NPAVHeap@@II@Z PROC	; LinkingPoolAllocator::init, COMDAT
; _this$ = ecx

; 10   : bool LinkingPoolAllocator::init(Heap* _heap, size_t _bucketSize, size_t _bucketsNum) {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __5A45405C_LinkingPoolAllocator@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 11   :     size_t requiredBucketSize = _bucketSize + sizeof(UsingBucketInfo);

	mov	eax, DWORD PTR __bucketSize$[ebp]
	add	eax, 8
	mov	DWORD PTR _requiredBucketSize$[ebp], eax

; 12   : 
; 13   :     assert(requiredBucketSize > sizeof(FreeBucketInfo));

	cmp	DWORD PTR _requiredBucketSize$[ebp], 4
	ja	SHORT $LN4@init
	mov	eax, DWORD PTR ?__LINE__Var@?0??init@LinkingPoolAllocator@@UAE_NPAVHeap@@II@Z@4JA
	add	eax, 3
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1PG@KGIOLBMI@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAt?$AAi?$AAm?$AA2?$AA3?$AA?2@
	push	OFFSET ??_C@_1FI@OPHLMCIO@?$AAr?$AAe?$AAq?$AAu?$AAi?$AAr?$AAe?$AAd?$AAB?$AAu?$AAc?$AAk?$AAe?$AAt?$AAS@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@init:

; 14   : 
; 15   :     size_t requiredSize = requiredBucketSize * _bucketsNum;

	mov	eax, DWORD PTR _requiredBucketSize$[ebp]
	imul	eax, DWORD PTR __bucketsNum$[ebp]
	mov	DWORD PTR _requiredSize$[ebp], eax

; 16   :     buckets = _heap->allocate(requiredSize);

	mov	eax, DWORD PTR _requiredSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __heap$[ebp]
	call	?allocate@Heap@@QAEPAXI@Z		; Heap::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 17   :     if (!buckets) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@init

; 18   :         return false;

	xor	al, al
	jmp	SHORT $LN1@init
$LN2@init:

; 19   :     }
; 20   : 
; 21   :     heap = _heap;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __heap$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 22   : 
; 23   :     bucketSize = _bucketSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __bucketSize$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 24   :     bucketsNum = _bucketsNum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __bucketsNum$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 25   : 
; 26   :     lastBucketInfo = (UsingBucketInfo*)((uint8_t*)buckets + bucketsNum * (bucketSize + sizeof(UsingBucketInfo)) - sizeof(UsingBucketInfo));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 8
	mov	edx, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [edx+24]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [edx+ecx-8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 27   : 
; 28   :     return true;

	mov	al, 1
$LN1@init:

; 29   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?init@LinkingPoolAllocator@@UAE_NPAVHeap@@II@Z ENDP	; LinkingPoolAllocator::init
_TEXT	ENDS
END
